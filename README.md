# پروژه MiniJava
 این پروژه با هدف اعمال code refactoring بر روی نسخه اولیه آن برای درس آز مهندسی نرم افزار ایجاد شده است.

## توضیح موارد بازآرایی اعمال شده
<br>

- مورد اول Facade: الگوی facade برای حذف کردن دسترسی های سیستم های بیرونی به محتویات درونی سیستم ها و کاهش وابستگی و پیچیدگی در نرم افزار است به گونه ای که یک واسط بر روی سیستم مورد نظر می نشیند و به عنوان یک API عمل میکند. در اینجا نیز بر روی codeGenerator به عنوان یک کامپوننت یا ساب سیستم، facade تعریف شده است.
- مورد دوم Facade: به مانند مورد قبل بر روی Scanner یک facade تعریف شده است.
- مورد Strategy: این الگو برای جداکردن الگوریتم های مختلف انجام یک کار از ساختار اصلی و واگذاری آن به یک ساختار توارثی دیگر و ایجاد یک ارتباط بین ساختار توارثی و کلاس اصلی است به گونه ای که در ران تایم، الگویتم مورد نظر اعمال می شود. در اینجا هم به طور ساده بر روی محتوای تولید شده از خروجی یک متود، این الگو به کار رفته است.
- مورد Separate Query From Modifier: در اینجا هدف جدا کردن دو کار مختلف Query یا لود کردن و خواندن از modify یا تغییر اعمال کردن جدا شده است. الگوی گسترده تر آن، CQRS است که کاربرد فراوانی دارد. در اینجا نیر همین امر به صورت ساده برای جا کردن عملیات خواندن و نوشتن اجرا شده است.
- مورد Extract Method: روش انجام این الگوی ریزدانه، به صورت خارج کردن یک متود از بدنه اصلی کد برای مشخص کردن و اتمیک کردن یک کار و جلوگیری از duplicate به کار گرفته شده است. با این کار modifiability نیز افزایش میابد. در اینجا نیز 2 متود به صورت مشخص شده در کامیت ها استخراج شده اند.
- مورد Remove Assignments to Parameters: در این رویکرد، از مقداردهی مجدد parameter های یک متود صرف نظر کرده و با آنها به صورت immutable برخورد میکنیم. در این صورت state سیستم بهتر حفظ می شود و خوانایی افزایش می یابد. در اینجا نیز در یکی از متودها این کار را کردیم.
- مورد Decompose Conditional: در اینجا یک شرط پیچیده و نامفهوم را، از بدنه if خارج کرده و به یک متود انتقال می دهیم. با این کار تغییر دادن آن آسان تر و خوانایی آن بالاتر و بهتر است. در اینجا نیز مطابق کامیت مربوطه، یک شرط در یک متود مناسب قرار داده شده است.

<br>

## سوالات
<br>

### سوال 1:
<br>

#### کد تمیز:
کد تمیز به کدی می‌گویند که اولا برنامه‌نویسان دیگر بتوانند آن را متوجه شوند، در ثانی دارای duplication نباشد، سعی شود در حد امکان از کلاس‌ها و به طور کل خط‌های کم‌تری داشته باشد، تمامی تست‌ها را پاس کند و به طور کل آسان‌تر و ارزان‌تر maintain شود.


#### بدهی فنی:
بدهی فنی را می‌توان به صورت کار عجله‌ای و یا بی‌دقت توسعه‌دهنده‌ها در قسمتی از توسعه‌ی نرم‌افزار تعریف کرد که بعدا خر تیم توسعه را خواهد گرفت و آنها مجبور می‌شوند که اوضاع را درست کنند. برای مثال اگر به خاطر شرایط بیزینسی تیمی مجبور شود featureی را زود عرضه کند که باگ داشته باشد و یا تمام نشده باشد مجبور می‌شود جلو‌تر با استفاده از patchها و غیره این کم‌کاری را بپوشاند.  


#### بوی بد:
بوی بد یا code smells نشان‌دهنده مشکلاتی هستند که در زمان refactoring می‌توان به آن‌ها رسید. معمولا code smells به راحتی قابل شناسایی و تعمیر هستند اما ممکن است آن‌ها نشان‌دهنده‌ی مشکلات بزرگ‌تر و عمیق‌تری درون برنامه‌ی ما باشند.  


### سوال 2:
<br>

#### نوع اول: Bloaters
مربوط به نوعی از bad smells است که کدها به شدت از نظر سایزی بزرگ و حجیم شدند که کار کردن با آن‌ها بسیار سخت می‌شود. این نوع semllها خیلی به تدریح در برنامه شروع به رشد می‌کنند.
#### نوع دوم: Object-Orientation Abusers
این smells مربوط به طراحی اشتباه یا ناقص از اصول برنامه‌نویسی شی‌گرا تولید می‌شوند.
#### نوع سوم: Change Preventers
وجود این نوع از smells یعنی در برنامه ما برای تغییری در یک بخش از کد باید مقدار زیادی از بخش‌های دیگر را نیز تغییر دهیم و این باعث می‌شود که نگهداری بسیار سخت و هزینه‌بر شود.
#### نوع چهارم: Dispensables
یک dispensable چیزی است که می‌شود از شرش خلاص شد به طوری که اگر از شرش خلاص شویم هیچ گونه ضرری به محصول ما وارد نشود و اتفاقا باعث شود که کد cleanتر شده و راحت‌تر بتوان آن را فهمید و توسعه داد.
#### نوع پنجم: Couplers
تمامی Semllهای داخل این گروه مربوط به این هستند که نشان دهند کاپلینگ زیاد وجود دارد و یا نشان دهند که اگر coupling را با delegation عوض کتیم چه اتفاقی میافتد.  

### سوال 3:  

#### مورد اول:
این بوی بد در دسته `Dispensables` قرار می‌گیرد.
#### مورد دوم:
اجزایی که تقریبا کارایی ندارند باید توسط `inline-class` باآرایی شوند. برای زیرکلاس‌هایی با متد‌های اندک می‌توان از بازآرایی `Collapse Hierarchy` استفاده کرد.  
#### مورد سوم:
بعضی وقت‌ها ممکن است یک Lazy Class برای معین کردن افدافمان در توسعه‌های آینده درست شده باشد. در این صورت ما باید یک توازن بین واضح بودن و سادگی را در کدمان رعایت کنیم.
